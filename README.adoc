= LadyLua
:toc:
:toc-placement!:

Single static executable, batteries-included, Lua 5.1 interpreter. A fat https://github.com/yuin/gopher-lua[GopherLua] amalgamation of modules in Go and Lua.

Current release: *0.3.0 Veggie Expediter* +
Next release: *0.4.0 Flying Squiggly* +
+ exec.cmd

toc::[]


++++
<p align="center">
<img src="ll.svg?raw=true"/>
</p>
++++

== Why?
Lua is a good language but no one wants to use it for general-purpose scripting. Complaints are 1-based indexing and missing libraries. The latter is a valid concern. The 5.2+ split also does not help. I was convinced that GopherLua would be a good base for a kitchen-sink interpreter. Writing wrappers for the vast selection of Go packages would be a breeze.

== Reference
Since GopherLua is an implementation of Lua 5.1, you can use the official Lua 5.1 reference manual: https://www.lua.org/manual/5.1/manual.html[Lua 5.1 Manual]. Other resources are also useful just make sure they do not target 5.2+ versions. Search for PDFs of Lua 5.1 cheatsheets. The Learn in in 15 minutes series also has an entry for http://tylerneylon.com/a/learn-lua/[Lua].

== Compiled-in modules

[options="header",width="88%"]
|===
|Module      |Global |Source           |License
|crypto      |N      |gluacrypto       |MIT
|exec        |Y      |                 |MIT
|fmt         |Y      |                 |MIT
|fs          |Y      |gopher-lfs       |Unlicense
|html        |N      |                 |MIT
|http        |N      |gluahttp         |MIT
|inspect     |N      |inspect          |MIT
|json        |N      |gopher-json      |Unlicense
|kapow       |N      |                 |MIT
|template    |N      |etlua            |MIT
|test        |N      |u-test           |MIT
|uid         |N      |                 |MIT
|===

:note-caption: :information_source:
[NOTE]
====
If it says *N* in the *Global* field, you need to `require()` it.
====

[NOTE]
====
Check the `docs` directory for more information about these modules.
====

== Documentation and Testing
Tests are in the `tests` directory. We are using `u-test`. Within the test code is the documentation in AsciiDoc. Generated docs are in the `docs` directory. Check the `scripts/docs` directory for the command line to generate the docs.

== Ideas
Besides general purpose scripting, a more specific use for me right now is using Lua for writing web apps. You can write it dynamic style like PHP but instead you have Lua. Another idea is hooking Go packages that interface with DevOps things. Instead of YAML you can program DevOps tools in Lua.

== SAMPLE: shell script converted to Lua
Check this https://github.com/tongson/LadyLua/commit/0a1949060627fbee309e5549f0d00d0299ace3de?branch=0a1949060627fbee309e5549f0d00d0299ace3de&diff=split[diff] to get a feel of the conversion from a shell script to Lua.

== Statistics and numbers
|=======================
|Tests |117/117
|Static executable bytes |7061504
|=======================

== Benchmark
Wonder how it compares to PUC-Rio Lua 5.1.5 and LuaJIT2?

Here's a benchmark for object access time. Check the `bench/` directory for the code. The results are from the default 100M runs. GopherLua is fast enough for unconvoluted work. It also demonstrates that LuaJIT is too smart for these benchmarks.

.GopherLua
|=======================
|72.804599166 |Standard (solid)
|85.15575082900001 |Standard (metatable)
|76.84095142800001 |Object using closures (PiL 16.4)
|56.77138606499997 |Object using closures (noself)
|54.96075333699997 |Direct Access
|32.508254155999964 |Local Variable
|=======================

.Lua 5.1.5
|=======================
|12.906285 |Standard (solid)
|13.649843 |Standard (metatable)
|13.294447 |Object using closures (PiL 16.4)
|9.024326  |Object using closures (noself)
|5.618169  |Direct Access
|1.76135   |Local Variable
|=======================

.LuaJIT 2.1
|=======================
|0.200721  |Standard (solid)
|0.200649  |Standard (metatable)
|0.200672  |Object using closures (PiL 16.4)
|0.200635  |Object using closures (noself)
|0.200627  |Direct Access
|0.200628  |Local Variable
|=======================

Before you go disabling function inlining to reduce the executable size; here are the benchmarks for it.

.GopherLua (disabled function inlining)
|=======================
|97.82842299|Standard (solid)
|117.51864293899999|Standard (metatable)
|103.283447037|Object using closures (PiL 16.4)
|66.51865570900003|Object using closures (noself)
|69.64288394199997|Direct Access
|37.33177725300004|Local Variable
|=======================

