= string
:toc:
:toc-placement!:

Functions added to the global `string` namespace.

toc::[]

== *string.append*(_String_, _String_) -> _String_
Append newline plus argument #2 string to argument #1 string.

=== Arguments
[width="72%"]
|===
|string| Original string
|string| String to append
|===

=== Returns
[width="72%"]
|===
|string| New string
|===

=== Example
----
local s = 'one'
local x = s:append'two'
assert(x=='one\ntwo')
----

== *string.word_to_list*(_String_) -> _Table_
Create a new table(list) where each alphanumeric sequence of argument #1 is a value in the list.

=== Arguments
[width="72%"]
|===
|string| Source string
|===

=== Returns
[width="72%"]
|===
|table| New table
|===

=== Example
----
local n = '1# 2! 3.'
local nt = n:word_to_list()
-- nt will contain { "1", "2", "3" }
----

== *string.to_list*(_String_) -> _Table_
Create a new table(list) where each non-space(%S) character of argument #1 is a value in the list.

=== Arguments
[width="72%"]
|===
|string| Source string
|===

=== Returns
[width="72%"]
|===
|table| New table
|===

=== Example
----
local z = 'one\ttwo'
local zt = z:to_list()
-- zt will contain {"one", "two"}
----

== *string.to_map*(_String_, _Value_) -> _Table_
Create a new table(map) where each non-space(%S) character of argument #1 is a key in the map. The second argument is any value to assign to each key, defaults to boolean `true`.

=== Arguments
[width="72%"]
|===
|string| Source string
|any |Value
|===

=== Returns
[width="72%"]
|===
|table| New table
|===
